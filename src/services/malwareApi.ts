import { MalwareSample, ThreatActor, MalwareActivity, MalwareAnalysis } from '@/types/malware';

const MALWARE_BAZAAR_API = 'https://mb-api.abuse.ch/api/v1/';
const THREATFOX_API = 'https://threatfox-api.abuse.ch/api/v1/';
const URLHAUS_API = 'https://urlhaus-api.abuse.ch/v1/';

// Helper to handle rate limiting
const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

export const malwareApi = {
  // Get recent malware samples
  async getRecentSamples(limit = 100): Promise<MalwareSample[]> {
    try {
      const formData = new FormData();
      formData.append('query', 'get_recent');
      formData.append('selector', limit.toString());

      const response = await fetch(MALWARE_BAZAAR_API, {
        method: 'POST',
        body: formData,
      });

      const data = await response.json();
      
      if (data.query_status === 'ok' && data.data) {
        return data.data. map((item: any) => ({
          id: item.sha256_hash,
          fileName: item. file_name || 'unknown',
          fileType: item.file_type || 'unknown',
          fileSize:  parseInt(item.file_size) || 0,
          hashes: {
            md5: item.md5_hash || '',
            sha1: item.sha1_hash || '',
            sha256: item.sha256_hash || '',
          },
          family: item.signature || 'Unknown',
          signature: item.signature || 'Generic',
          tags: item.tags || [],
          firstSeen:  item.first_seen || new Date().toISOString(),
          lastSeen: item.last_seen || new Date().toISOString(),
          reporterName: item.reporter || 'Anonymous',
          threatLevel: determineThreatLevel(item.tags),
          downloads: parseInt(item. delivery_method) || 0,
          uploadsCount: 1,
        }));
      }
      return [];
    } catch (error) {
      console.error('Error fetching recent samples:', error);
      return [];
    }
  },

  // Search by hash
  async searchByHash(hash: string): Promise<MalwareSample | null> {
    try {
      const formData = new FormData();
      formData.append('query', 'get_info');
      formData.append('hash', hash);

      const response = await fetch(MALWARE_BAZAAR_API, {
        method: 'POST',
        body: formData,
      });

      const data = await response.json();
      
      if (data.query_status === 'ok' && data.data && data.data.length > 0) {
        const item = data.data[0];
        return {
          id: item.sha256_hash,
          fileName: item.file_name || 'unknown',
          fileType: item.file_type || 'unknown',
          fileSize:  parseInt(item.file_size) || 0,
          hashes: {
            md5: item.md5_hash || '',
            sha1: item.sha1_hash || '',
            sha256: item.sha256_hash || '',
          },
          family:  item.signature || 'Unknown',
          signature: item.signature || 'Generic',
          tags:  item.tags || [],
          firstSeen: item.first_seen || new Date().toISOString(),
          lastSeen: item.last_seen || new Date().toISOString(),
          reporterName: item.reporter || 'Anonymous',
          threatLevel:  determineThreatLevel(item. tags),
          downloads: 0,
          uploadsCount: 1,
        };
      }
      return null;
    } catch (error) {
      console.error('Error searching by hash:', error);
      return null;
    }
  },

  // Get malware by signature/family
  async searchBySignature(signature: string, limit = 50): Promise<MalwareSample[]> {
    try {
      const formData = new FormData();
      formData.append('query', 'get_sigcheck');
      formData.append('signature', signature);
      formData.append('limit', limit.toString());

      const response = await fetch(MALWARE_BAZAAR_API, {
        method:  'POST',
        body:  formData,
      });

      const data = await response.json();
      
      if (data. query_status === 'ok' && data.data) {
        return data.data.map((item: any) => ({
          id: item.sha256_hash,
          fileName: item.file_name || 'unknown',
          fileType: item.file_type || 'unknown',
          fileSize: parseInt(item.file_size) || 0,
          hashes: {
            md5: item.md5_hash || '',
            sha1: item. sha1_hash || '',
            sha256: item.sha256_hash || '',
          },
          family: item.signature || 'Unknown',
          signature: item. signature || 'Generic',
          tags: item.tags || [],
          firstSeen: item.first_seen || new Date().toISOString(),
          lastSeen: item.last_seen || new Date().toISOString(),
          reporterName: item.reporter || 'Anonymous',
          threatLevel: determineThreatLevel(item.tags),
          downloads: 0,
          uploadsCount: 1,
        }));
      }
      return [];
    } catch (error) {
      console.error('Error searching by signature:', error);
      return [];
    }
  },

  // Get threat intelligence from ThreatFox
  async getThreatIntel(limit = 100): Promise<any[]> {
    try {
      const response = await fetch(THREATFOX_API, {
        method:  'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          query: 'get_iocs',
          days: 7,
        }),
      });

      const data = await response.json();
      
      if (data.query_status === 'ok' && data.data) {
        return data.data.slice(0, limit);
      }
      return [];
    } catch (error) {
      console.error('Error fetching threat intel:', error);
      return [];
    }
  },

  // Get malicious URLs
  async getMaliciousUrls(limit = 100): Promise<any[]> {
    try {
      const response = await fetch(`${URLHAUS_API}urls/recent/limit/${limit}/`, {
        method: 'GET',
      });

      const data = await response.json();
      
      if (data.query_status === 'ok' && data.urls) {
        return data.urls;
      }
      return [];
    } catch (error) {
      console.error('Error fetching malicious URLs:', error);
      return [];
    }
  },

  // AI-powered analysis aggregation
  async analyzeWithAI(hash: string, additionalData?:  any): Promise<MalwareAnalysis | null> {
    try {
      // First get base data
      const sample = await this.searchByHash(hash);
      if (!sample) return null;

      // Get threat intel
      await delay(1000); // Rate limiting
      const threatIntel = await this.getThreatIntel(50);
      
      // Find related IOCs
      const relatedIOCs = threatIntel.filter((ioc: any) => 
        ioc.malware_printable === sample.family ||
        ioc.tags?. some((tag: string) => sample.tags. includes(tag))
      );

      // Extract IOCs
      const ips = new Set<string>();
      const domains = new Set<string>();
      const urls = new Set<string>();
      
      relatedIOCs.forEach((ioc: any) => {
        if (ioc.ioc_type === 'ip: port' || ioc.ioc_type === 'ip') {
          ips.add(ioc.ioc. split(':')[0]);
        } else if (ioc.ioc_type === 'domain') {
          domains.add(ioc. ioc);
        } else if (ioc.ioc_type === 'url') {
          urls.add(ioc.ioc);
        }
      });

      // Determine threat actors (simplified logic)
      const threatActors = determineThreatActors(sample. family, sample.tags);
      
      // Determine capabilities
      const capabilities = determineCapabilities(sample.fileType, sample.tags);
      
      // Generate behavior patterns
      const behavior = generateBehaviorPatterns(sample.family, sample.tags);

      return {
        hash: sample.hashes.sha256,
        fileName: sample. fileName,
        verdict: `${sample.family} - ${sample.threatLevel. toUpperCase()} threat`,
        confidence: calculateConfidence(sample, relatedIOCs. length),
        malwareFamily:  sample.family,
        threatActors,
        capabilities,
        iocs: {
          ips:  Array.from(ips),
          domains: Array.from(domains),
          urls: Array.from(urls),
          fileHashes: [sample.hashes.md5, sample.hashes.sha1, sample.hashes.sha256],
        },
        behavior,
        signatures: [sample.signature],
        yara_rules: generateYaraRules(sample),
        sandbox_reports: [],
      };
    } catch (error) {
      console.error('Error analyzing with AI:', error);
      return null;
    }
  },

  // Get malware families statistics
  async getMalwareFamilies(): Promise<Map<string, number>> {
    try {
      const samples = await this.getRecentSamples(1000);
      const familyMap = new Map<string, number>();
      
      samples.forEach(sample => {
        const count = familyMap.get(sample.family) || 0;
        familyMap.set(sample.family, count + 1);
      });
      
      return familyMap;
    } catch (error) {
      console.error('Error getting malware families:', error);
      return new Map();
    }
  },
};

// Helper functions
function determineThreatLevel(tags: string[]): 'critical' | 'high' | 'medium' | 'low' {
  if (! tags || tags.length === 0) return 'medium';
  
  const criticalTags = ['ransomware', 'wiper', 'rootkit', 'bootkit'];
  const highTags = ['trojan', 'rat', 'stealer', 'backdoor'];
  const mediumTags = ['adware', 'spyware', 'downloader'];
  
  if (tags.some(tag => criticalTags.includes(tag. toLowerCase()))) return 'critical';
  if (tags.some(tag => highTags.includes(tag.toLowerCase()))) return 'high';
  if (tags. some(tag => mediumTags.includes(tag.toLowerCase()))) return 'medium';
  
  return 'low';
}

function determineThreatActors(family: string, tags: string[]): string[] {
  const actorMap:  Record<string, string[]> = {
    'AgentTesla': ['Unknown APT', 'Cybercrime Groups'],
    'AsyncRAT': ['Various Cybercrime Groups'],
    'RedLine': ['RedLine Cartel'],
    'Emotet': ['TA542', 'Mealybug'],
    'TrickBot': ['Wizard Spider'],
    'Conti': ['Wizard Spider', 'Conti Group'],
    'Cobalt Strike': ['Various APT Groups', 'Red Team Tools'],
    'Remcos': ['Various Cybercrime Groups'],
    'njRAT': ['Middle Eastern Threat Actors'],
    'XMRig': ['Cryptojacking Groups'],
  };
  
  return actorMap[family] || ['Unknown Threat Actor'];
}

function determineCapabilities(fileType: string, tags: string[]): string[] {
  const capabilities: string[] = [];
  
  if (tags.includes('ransomware')) capabilities.push('File Encryption', 'Ransom Note Generation');
  if (tags.includes('stealer')) capabilities.push('Credential Theft', 'Browser Data Exfiltration');
  if (tags.includes('rat') || tags.includes('trojan')) capabilities.push('Remote Access', 'Command Execution');
  if (tags.includes('downloader')) capabilities.push('Download Additional Payloads');
  if (tags.includes('miner')) capabilities.push('Cryptocurrency Mining');
  if (fileType.includes('exe')) capabilities.push('Windows Executable');
  if (fileType.includes('dll')) capabilities.push('DLL Injection');
  if (fileType.includes('doc') || fileType.includes('xls')) capabilities.push('Office Macro Execution');
  
  return capabilities. length > 0 ? capabilities : ['Unknown Capabilities'];
}

function generateBehaviorPatterns(family: string, tags: string[]): string[] {
  const behaviors: string[] = [];
  
  behaviors.push('File system modification detected');
  behaviors.push('Network communication established');
  
  if (tags.includes('ransomware')) {
    behaviors.push('Mass file encryption activity');
    behaviors.push('Shadow copy deletion');
    behaviors.push('Ransom note creation');
  }
  
  if (tags.includes('stealer')) {
    behaviors.push('Browser data access');
    behaviors.push('Credential harvesting');
    behaviors.push('Data exfiltration via HTTP/HTTPS');
  }
  
  if (tags.includes('rat')) {
    behaviors.push('Establishes persistence mechanisms');
    behaviors.push('Remote command execution capability');
    behaviors.push('Keylogging activity');
  }
  
  return behaviors;
}

function calculateConfidence(sample: MalwareSample, relatedIOCsCount: number): number {
  let confidence = 0.5;
  
  if (sample.signature !== 'Generic') confidence += 0.2;
  if (sample.tags.length > 0) confidence += 0.1;
  if (relatedIOCsCount > 0) confidence += 0.1;
  if (sample.reporterName !== 'Anonymous') confidence += 0.1;
  
  return Math.min(confidence, 1.0);
}

function generateYaraRules(sample: MalwareSample): string[] {
  return [
    `rule ${sample.family. replace(/[^a-zA-Z0-9]/g, '_')}_Detection {
      meta:
        description = "Detects ${sample. family}"
        hash = "${sample.hashes.sha256}"
      strings:
        $s1 = "${sample.fileName}"
      condition:
        any of them
    }`,
  ];
}
