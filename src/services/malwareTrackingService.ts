// ============================================================================
// malwareTrackingService.ts
// ADVANCED MALWARE ACTIVITY TRACKING - StealthMole Style
// ============================================================================
// ✔ C2/C&C Server Tracking
// ✔ Ransomware Group Monitoring
// ✔ Stealer Log Detection (RedLine, Raccoon, Vidar, etc.)
// ✔ RAT/Botnet Activity
// ✔ Malware Sample Analysis
// ✔ IOC Extraction & Correlation
// ============================================================================

import { cacheAPIResponse, getCachedData } from '@/lib/database';

/* ============================================================================
   TYPES
============================================================================ */

export type MalwareCategory = 
  | 'ransomware' 
  | 'stealer' 
  | 'rat' 
  | 'botnet' 
  | 'trojan' 
  | 'worm' 
  | 'rootkit'
  | 'cryptominer'
  | 'loader'
  | 'backdoor'
  | 'apt'
  | 'unknown';

export type ThreatSeverity = 'critical' | 'high' | 'medium' | 'low';

export interface MalwareIndicator {
  id: string;
  type: 'ip' | 'domain' | 'url' | 'hash' | 'email' | 'wallet';
  value: string;
  malwareFamily: string;
  category: MalwareCategory;
  severity: ThreatSeverity;
  firstSeen: string;
  lastSeen: string;
  source: string;
  sourceUrl: string;
  confidence: number;
  tags: string[];
  relatedIndicators?: string[];
  mitreAttack?: string[];
  description: string;
}

export interface RansomwareGroup {
  id: string;
  name: string;
  aliases: string[];
  active: boolean;
  firstSeen: string;
  lastActivity: string;
  victimCount: number;
  targetSectors: string[];
  targetCountries: string[];
  ttps: string[];
  ransomNote?: string;
  extensions: string[];
  leakSite?: string;
  contactMethods: string[];
  description: string;
  iocs: MalwareIndicator[];
}

export interface StealerLog {
  id: string;
  stealerFamily: string; // RedLine, Raccoon, Vidar, etc.
  timestamp: string;
  source: string;
  sourceUrl: string;
  affectedDomain: string;
  credentialCount: number;
  cookieCount: number;
  cardCount: number;
  walletCount: number;
  severity: ThreatSeverity;
  preview: string;
  tags: string[];
}

export interface C2Server {
  id: string;
  ip: string;
  domain?: string;
  port: number;
  protocol: string;
  malwareFamily: string;
  category: MalwareCategory;
  status: 'active' | 'inactive' | 'sinkholed';
  firstSeen: string;
  lastSeen: string;
  geoLocation?: {
    country: string;
    city?: string;
    asn?: string;
    org?: string;
  };
  tlsFingerprint?: string;
  jarm?: string;
  beaconInterval?: number;
  source: string;
  confidence: number;
}

export interface MalwareSample {
  id: string;
  sha256: string;
  sha1?: string;
  md5?: string;
  fileName?: string;
  fileSize?: number;
  fileType: string;
  malwareFamily: string;
  category: MalwareCategory;
  severity: ThreatSeverity;
  firstSeen: string;
  lastSeen: string;
  detectionRatio?: string;
  tags: string[];
  c2Servers: string[];
  droppedFiles?: string[];
  mitreAttack: string[];
  source: string;
  sourceUrl: string;
}

export interface ThreatActorProfile {
  id: string;
  name: string;
  aliases: string[];
  type: 'apt' | 'cybercrime' | 'hacktivist' | 'iab' | 'unknown';
  motivation: string[];
  targetSectors: string[];
  targetCountries: string[];
  ttps: string[];
  tools: string[];
  active: boolean;
  firstSeen: string;
  lastActivity: string;
  description: string;
  iocs: MalwareIndicator[];
  relatedGroups: string[];
}

export interface MalwareSearchResult {
  indicators: MalwareIndicator[];
  ransomwareGroups: RansomwareGroup[];
  stealerLogs: StealerLog[];
  c2Servers: C2Server[];
  malwareSamples: MalwareSample[];
  threatActors: ThreatActorProfile[];
  stats: {
    totalIndicators: number;
    criticalThreats: number;
    activeC2s: number;
    ransomwareMatches: number;
    stealerLogHits: number;
  };
  analysisTime: number;
}

/* ============================================================================
   CONSTANTS
============================================================================ */

const CORS_PROXY = 'https://api.allorigins.win/raw?url=';

// Known ransomware groups for tracking
const KNOWN_RANSOMWARE_GROUPS = [
  { name: 'LockBit', aliases: ['LockBit 3.0', 'LockBit Black'], active: true },
  { name: 'BlackCat', aliases: ['ALPHV', 'Noberus'], active: true },
  { name: 'Cl0p', aliases: ['Clop', 'TA505'], active: true },
  { name: 'Royal', aliases: ['Royal Ransomware'], active: true },
  { name: 'Play', aliases: ['PlayCrypt'], active: true },
  { name: 'Black Basta', aliases: ['BlackBasta'], active: true },
  { name: 'Medusa', aliases: ['MedusaLocker'], active: true },
  { name: 'Akira', aliases: [], active: true },
  { name: 'Rhysida', aliases: [], active: true },
  { name: 'NoEscape', aliases: ['Avaddon successor'], active: true },
  { name: '8Base', aliases: [], active: true },
  { name: 'Hunters International', aliases: ['Hive successor'], active: true },
  { name: 'BianLian', aliases: [], active: true },
  { name: 'Cactus', aliases: [], active: true },
  { name: 'INC Ransom', aliases: ['INC'], active: true },
];

// Known stealer families
const KNOWN_STEALERS = [
  'RedLine', 'Raccoon', 'Vidar', 'Meta', 'Lumma', 'Stealc',
  'Aurora', 'Mars', 'Arkei', 'Oski', 'Taurus', 'Prynt', 'WorldWind'
];

// Known RAT families
const KNOWN_RATS = [
  'AsyncRAT', 'QuasarRAT', 'NjRAT', 'DarkComet', 'Remcos', 'Agent Tesla',
  'NanoCore', 'Warzone', 'Orcus', 'LimeRAT', 'XWorm', 'DCRat'
];

// MITRE ATT&CK mapping for common techniques
const MITRE_TECHNIQUES: Record<string, string[]> = {
  ransomware: ['T1486', 'T1490', 'T1489', 'T1059', 'T1547'],
  stealer: ['T1555', 'T1539', 'T1552', 'T1056', 'T1113'],
  rat: ['T1219', 'T1071', 'T1105', 'T1059', 'T1547'],
  botnet: ['T1583', 'T1584', 'T1071', 'T1090', 'T1573'],
  loader: ['T1129', 'T1055', 'T1106', 'T1059'],
};

/* ============================================================================
   UTILITY FUNCTIONS
============================================================================ */

const nowISO = () => new Date().toISOString();

function makeId(prefix: string): string {
  return `${prefix}_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 10)}`;
}

function isRelevantResult(text: string, query: string): boolean {
  if (!text || !query) return false;
  const textLower = text.toLowerCase();
  const queryLower = query.toLowerCase().trim();
  return textLower.includes(queryLower);
}

function extractIOCs(text: string): { type: string; value: string }[] {
  const iocs: { type: string; value: string }[] = [];
  
  // IP addresses
  const ipRegex = /\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b/g;
  (text.match(ipRegex) || []).forEach(ip => {
    if (!ip.startsWith('10.') && !ip.startsWith('192.168.') && !ip.startsWith('127.')) {
      iocs.push({ type: 'ip', value: ip });
    }
  });
  
  // Domains
  const domainRegex = /\b(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+(?:onion|com|net|org|io|ru|cn|tk|ml|ga|cf|xyz|top|pw|cc|ws|biz|info)\b/gi;
  (text.match(domainRegex) || []).forEach(domain => {
    iocs.push({ type: 'domain', value: domain.toLowerCase() });
  });
  
  // SHA256
  const sha256Regex = /\b[a-fA-F0-9]{64}\b/g;
  (text.match(sha256Regex) || []).forEach(hash => {
    iocs.push({ type: 'sha256', value: hash.toLowerCase() });
  });
  
  // MD5
  const md5Regex = /\b[a-fA-F0-9]{32}\b/g;
  (text.match(md5Regex) || []).forEach(hash => {
    if (!text.match(sha256Regex)?.some(h => h.includes(hash))) {
      iocs.push({ type: 'md5', value: hash.toLowerCase() });
    }
  });
  
  // URLs
  const urlRegex = /https?:\/\/[^\s<>"']+/gi;
  (text.match(urlRegex) || []).forEach(url => {
    iocs.push({ type: 'url', value: url });
  });
  
  // Crypto wallets
  const btcRegex = /\b[13][a-km-zA-HJ-NP-Z1-9]{25,34}\b/g;
  const ethRegex = /\b0x[a-fA-F0-9]{40}\b/g;
  (text.match(btcRegex) || []).forEach(addr => iocs.push({ type: 'btc_wallet', value: addr }));
  (text.match(ethRegex) || []).forEach(addr => iocs.push({ type: 'eth_wallet', value: addr }));
  
  return iocs;
}

function detectMalwareFamily(text: string): { family: string; category: MalwareCategory; confidence: number } {
  const t = text.toLowerCase();
  
  // Check for ransomware
  for (const group of KNOWN_RANSOMWARE_GROUPS) {
    if (t.includes(group.name.toLowerCase()) || 
        group.aliases.some(a => t.includes(a.toLowerCase()))) {
      return { family: group.name, category: 'ransomware', confidence: 0.9 };
    }
  }
  
  // Check for stealers
  for (const stealer of KNOWN_STEALERS) {
    if (t.includes(stealer.toLowerCase())) {
      return { family: stealer, category: 'stealer', confidence: 0.85 };
    }
  }
  
  // Check for RATs
  for (const rat of KNOWN_RATS) {
    if (t.includes(rat.toLowerCase())) {
      return { family: rat, category: 'rat', confidence: 0.85 };
    }
  }
  
  // Generic detection
  if (/(ransom|encrypt|decrypt|\.locked|\.encrypted)/i.test(t)) {
    return { family: 'Unknown Ransomware', category: 'ransomware', confidence: 0.6 };
  }
  if (/(stealer|password|credential|cookie|wallet)/i.test(t)) {
    return { family: 'Unknown Stealer', category: 'stealer', confidence: 0.5 };
  }
  if (/(rat|remote.?access|c2|c&c|beacon)/i.test(t)) {
    return { family: 'Unknown RAT', category: 'rat', confidence: 0.5 };
  }
  if (/(botnet|ddos|zombie|infected.?host)/i.test(t)) {
    return { family: 'Unknown Botnet', category: 'botnet', confidence: 0.5 };
  }
  if (/(cryptominer|miner|monero|xmr)/i.test(t)) {
    return { family: 'Cryptominer', category: 'cryptominer', confidence: 0.7 };
  }
  if (/(loader|dropper|downloader)/i.test(t)) {
    return { family: 'Loader', category: 'loader', confidence: 0.6 };
  }
  
  return { family: 'Unknown', category: 'unknown', confidence: 0.3 };
}

function determineSeverity(text: string, category: MalwareCategory): ThreatSeverity {
  const t = text.toLowerCase();
  
  // Critical threats
  if (category === 'ransomware') return 'critical';
  if (/(active|ongoing|0day|zero.?day|critical|breach|compromised)/i.test(t)) return 'critical';
  if (/(apt|nation.?state|advanced.?persistent)/i.test(t)) return 'critical';
  
  // High threats
  if (category === 'stealer' || category === 'rat') return 'high';
  if (/(credential|password|leak|dump)/i.test(t)) return 'high';
  
  // Medium
  if (category === 'botnet' || category === 'loader') return 'medium';
  
  return 'low';
}

/* ============================================================================
   SOURCE 1: ThreatFox IOC Database (FREE API)
============================================================================ */

async function searchThreatFox(query: string): Promise<MalwareIndicator[]> {
  const indicators: MalwareIndicator[] = [];
  
  try {
    // ThreatFox search
    
    // ThreatFox API endpoint
    const res = await fetch('https://threatfox-api.abuse.ch/api/v1/', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query: 'search_ioc', search_term: query }),
    });
    
    if (!res.ok) return [];
    
    const data = await res.json();
    const iocs = data.data || [];
    
    iocs.forEach((ioc: any) => {
      const detection = detectMalwareFamily(ioc.malware || ioc.tags?.join(' ') || '');
      
      indicators.push({
        id: makeId('tf'),
        type: ioc.ioc_type?.includes('ip') ? 'ip' : 
              ioc.ioc_type?.includes('domain') ? 'domain' :
              ioc.ioc_type?.includes('url') ? 'url' : 'hash',
        value: ioc.ioc,
        malwareFamily: ioc.malware || detection.family,
        category: detection.category,
        severity: determineSeverity(ioc.malware || '', detection.category),
        firstSeen: ioc.first_seen || nowISO(),
        lastSeen: ioc.last_seen || nowISO(),
        source: 'ThreatFox',
        sourceUrl: `https://threatfox.abuse.ch/ioc/${ioc.id}`,
        confidence: ioc.confidence_level || 75,
        tags: ioc.tags || [],
        mitreAttack: MITRE_TECHNIQUES[detection.category] || [],
        description: ioc.reporter || 'ThreatFox IOC',
      });
    });
    
    // Found IOCs
    return indicators;
  } catch (err) {
    // ThreatFox error
    return [];
  }
}

/* ============================================================================
   SOURCE 2: URLhaus Malware URLs (FREE)
============================================================================ */

async function searchURLhaus(query: string): Promise<MalwareIndicator[]> {
  const indicators: MalwareIndicator[] = [];
  
  try {
    // URLhaus search
    
    // Search via tag or payload
    const res = await fetch('https://urlhaus-api.abuse.ch/v1/tag/' + encodeURIComponent(query) + '/', {
      method: 'POST',
    });
    
    if (!res.ok) return [];
    
    const data = await res.json();
    const urls = data.urls || [];
    
    urls.forEach((item: any) => {
      const detection = detectMalwareFamily(item.tags?.join(' ') || item.threat || '');
      
      if (!isRelevantResult(JSON.stringify(item), query)) return;
      
      indicators.push({
        id: makeId('uh'),
        type: 'url',
        value: item.url,
        malwareFamily: item.threat || detection.family,
        category: detection.category,
        severity: item.threat?.toLowerCase().includes('ransomware') ? 'critical' : 'high',
        firstSeen: item.date_added || nowISO(),
        lastSeen: item.last_online || nowISO(),
        source: 'URLhaus',
        sourceUrl: item.urlhaus_reference || 'https://urlhaus.abuse.ch',
        confidence: 80,
        tags: item.tags || [],
        mitreAttack: MITRE_TECHNIQUES[detection.category] || [],
        description: `Threat: ${item.threat || 'Unknown'}`,
      });
    });
    
    // Found malicious URLs
    return indicators;
  } catch (err) {
    // URLhaus error
    return [];
  }
}

/* ============================================================================
   SOURCE 3: MalwareBazaar Samples (FREE)
============================================================================ */

async function searchMalwareBazaar(query: string): Promise<MalwareSample[]> {
  const samples: MalwareSample[] = [];
  
  try {
    console.log(`[MalwareBazaar] Searching for: "${query}"`);
    
    // Search by tag/signature
    const res = await fetch('https://mb-api.abuse.ch/api/v1/', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: `query=get_taginfo&tag=${encodeURIComponent(query)}&limit=25`,
    });
    
    if (!res.ok) return [];
    
    const data = await res.json();
    const malwareData = data.data || [];
    
    malwareData.forEach((item: any) => {
      const detection = detectMalwareFamily(item.signature || item.tags?.join(' ') || '');
      
      samples.push({
        id: makeId('mb'),
        sha256: item.sha256_hash,
        sha1: item.sha1_hash,
        md5: item.md5_hash,
        fileName: item.file_name,
        fileSize: item.file_size,
        fileType: item.file_type || 'unknown',
        malwareFamily: item.signature || detection.family,
        category: detection.category,
        severity: determineSeverity(item.signature || '', detection.category),
        firstSeen: item.first_seen || nowISO(),
        lastSeen: item.last_seen || nowISO(),
        tags: item.tags || [],
        c2Servers: [],
        mitreAttack: MITRE_TECHNIQUES[detection.category] || [],
        source: 'MalwareBazaar',
        sourceUrl: `https://bazaar.abuse.ch/sample/${item.sha256_hash}/`,
      });
    });
    
    console.log(`[MalwareBazaar] ✅ Found ${samples.length} samples`);
    return samples;
  } catch (err) {
    console.error('[MalwareBazaar] ❌ Error:', err);
    return [];
  }
}

/* ============================================================================
   SOURCE 4: Feodo Tracker - C2 Servers (FREE)
============================================================================ */

async function searchFeodoTracker(query: string): Promise<C2Server[]> {
  const servers: C2Server[] = [];
  
  try {
    console.log(`[FeodoTracker] Searching for C2 servers...`);
    
    // Get recent C2 servers
    const res = await fetch('https://feodotracker.abuse.ch/downloads/ipblocklist_recommended.json');
    
    if (!res.ok) return [];
    
    const data = await res.json();
    const c2List = Array.isArray(data) ? data : [];
    
    // Filter by query
    c2List.filter((item: any) => 
      isRelevantResult(JSON.stringify(item), query) ||
      query.toLowerCase() === 'c2' ||
      query.toLowerCase() === 'botnet'
    ).forEach((item: any) => {
      const detection = detectMalwareFamily(item.malware || '');
      
      servers.push({
        id: makeId('feodo'),
        ip: item.ip_address || item.dst_ip,
        port: item.dst_port || 443,
        protocol: 'TCP',
        malwareFamily: item.malware || detection.family,
        category: detection.category !== 'unknown' ? detection.category : 'botnet',
        status: item.status === 'online' ? 'active' : 'inactive',
        firstSeen: item.first_seen || nowISO(),
        lastSeen: item.last_online || nowISO(),
        geoLocation: {
          country: item.country || 'Unknown',
          asn: item.as_number,
          org: item.as_name,
        },
        source: 'FeodoTracker',
        confidence: 90,
      });
    });
    
    console.log(`[FeodoTracker] ✅ Found ${servers.length} C2 servers`);
    return servers;
  } catch (err) {
    console.error('[FeodoTracker] ❌ Error:', err);
    return [];
  }
}

/* ============================================================================
   SOURCE 5: SSL Blacklist - Malicious SSL Certs (FREE)
============================================================================ */

async function searchSSLBL(query: string): Promise<MalwareIndicator[]> {
  const indicators: MalwareIndicator[] = [];
  
  try {
    console.log(`[SSLBL] Searching for malicious SSL certificates...`);
    
    const res = await fetch('https://sslbl.abuse.ch/blacklist/sslipblacklist.json');
    
    if (!res.ok) return [];
    
    const data = await res.json();
    const entries = Array.isArray(data) ? data : [];
    
    entries.filter((item: any) =>
      isRelevantResult(JSON.stringify(item), query) ||
      query.toLowerCase().includes('ssl') ||
      query.toLowerCase().includes('cert')
    ).forEach((item: any) => {
      const detection = detectMalwareFamily(item.listing_reason || '');
      
      indicators.push({
        id: makeId('sslbl'),
        type: 'ip',
        value: item.ip_address,
        malwareFamily: detection.family,
        category: detection.category,
        severity: 'high',
        firstSeen: item.listing_date || nowISO(),
        lastSeen: nowISO(),
        source: 'SSLBL',
        sourceUrl: 'https://sslbl.abuse.ch',
        confidence: 85,
        tags: ['ssl', 'malicious-cert'],
        mitreAttack: ['T1573'],
        description: item.listing_reason || 'Malicious SSL certificate',
      });
    });
    
    console.log(`[SSLBL] ✅ Found ${indicators.length} malicious SSL entries`);
    return indicators;
  } catch (err) {
    console.error('[SSLBL] ❌ Error:', err);
    return [];
  }
}

/* ============================================================================
   SOURCE 6: Ransomware.live - Ransomware Group Tracking (FREE)
============================================================================ */

async function searchRansomwareLive(query: string): Promise<RansomwareGroup[]> {
  const groups: RansomwareGroup[] = [];
  
  try {
    console.log(`[Ransomware.live] Searching ransomware groups...`);
    
    // Get ransomware group data
    const res = await fetch(`${CORS_PROXY}${encodeURIComponent('https://ransomware.live/api/groups')}`);
    
    if (!res.ok) {
      // Fallback to known groups
      const matchingGroups = KNOWN_RANSOMWARE_GROUPS.filter(g =>
        g.name.toLowerCase().includes(query.toLowerCase()) ||
        g.aliases.some(a => a.toLowerCase().includes(query.toLowerCase())) ||
        query.toLowerCase() === 'ransomware'
      );
      
      matchingGroups.forEach(g => {
        groups.push({
          id: makeId('rwg'),
          name: g.name,
          aliases: g.aliases,
          active: g.active,
          firstSeen: '2023-01-01T00:00:00Z',
          lastActivity: nowISO(),
          victimCount: 0,
          targetSectors: ['All'],
          targetCountries: ['Worldwide'],
          ttps: MITRE_TECHNIQUES.ransomware,
          extensions: [],
          contactMethods: ['Tor', 'Email'],
          description: `${g.name} ransomware group`,
          iocs: [],
        });
      });
      
      return groups;
    }
    
    const data = await res.json();
    const groupList = Array.isArray(data) ? data : [];
    
    groupList.filter((g: any) =>
      g.name?.toLowerCase().includes(query.toLowerCase()) ||
      query.toLowerCase() === 'ransomware'
    ).forEach((g: any) => {
      groups.push({
        id: makeId('rwg'),
        name: g.name,
        aliases: g.aliases || [],
        active: g.active !== false,
        firstSeen: g.first_seen || '2023-01-01T00:00:00Z',
        lastActivity: g.last_activity || nowISO(),
        victimCount: g.victim_count || 0,
        targetSectors: g.sectors || [],
        targetCountries: g.countries || [],
        ttps: MITRE_TECHNIQUES.ransomware,
        extensions: g.extensions || [],
        leakSite: g.leak_site,
        contactMethods: g.contact || [],
        description: g.description || `${g.name} ransomware group`,
        iocs: [],
      });
    });
    
    console.log(`[Ransomware.live] ✅ Found ${groups.length} ransomware groups`);
    return groups;
  } catch (err) {
    console.error('[Ransomware.live] ❌ Error:', err);
    return [];
  }
}

/* ============================================================================
   SOURCE 7: GitHub Threat Intel Search
============================================================================ */

async function searchGitHubMalware(query: string): Promise<MalwareIndicator[]> {
  const indicators: MalwareIndicator[] = [];
  
  try {
    console.log(`[GitHub Malware] Searching for: "${query}"`);
    
    // Search threat intel repos
    const searchTerms = `"${query}" malware OR ioc OR c2 OR ransomware`;
    const url = `https://api.github.com/search/code?q=${encodeURIComponent(searchTerms)}&per_page=20`;
    
    const res = await fetch(url, {
      headers: {
        'Accept': 'application/vnd.github.v3+json',
        'User-Agent': 'OSINT-Hub/2.0',
      },
    });
    
    if (res.status === 403) {
      console.warn('[GitHub Malware] Rate limited');
      return [];
    }
    
    if (!res.ok) return [];
    
    const data = await res.json();
    const items = data.items || [];
    
    items.forEach((item: any) => {
      const detection = detectMalwareFamily(item.name + ' ' + item.path);
      const iocs = extractIOCs(item.path + ' ' + item.name);
      
      iocs.forEach(ioc => {
        indicators.push({
          id: makeId('ghm'),
          type: ioc.type as any,
          value: ioc.value,
          malwareFamily: detection.family,
          category: detection.category,
          severity: determineSeverity(item.name, detection.category),
          firstSeen: nowISO(),
          lastSeen: nowISO(),
          source: 'GitHub',
          sourceUrl: item.html_url,
          confidence: 60,
          tags: ['github', 'osint'],
          description: `Found in ${item.repository?.full_name}`,
        });
      });
    });
    
    console.log(`[GitHub Malware] ✅ Found ${indicators.length} indicators`);
    return indicators;
  } catch (err) {
    console.error('[GitHub Malware] ❌ Error:', err);
    return [];
  }
}

/* ============================================================================
   SOURCE 8: Reddit Threat Intel
============================================================================ */

async function searchRedditMalware(query: string): Promise<MalwareIndicator[]> {
  const indicators: MalwareIndicator[] = [];
  
  try {
    console.log(`[Reddit Malware] Searching for: "${query}"`);
    
    const url = `https://www.reddit.com/r/malware+netsec+cybersecurity/search.json?q="${encodeURIComponent(query)}"&sort=relevance&limit=25`;
    
    const res = await fetch(url, {
      headers: { 'User-Agent': 'OSINT-Hub/2.0' },
    });
    
    if (!res.ok) return [];
    
    const data = await res.json();
    const posts = data.data?.children || [];
    
    posts.forEach((post: any) => {
      const p = post.data;
      const text = `${p.title} ${p.selftext || ''}`;
      
      if (!isRelevantResult(text, query)) return;
      
      const detection = detectMalwareFamily(text);
      const iocs = extractIOCs(text);
      
      // Create indicator for the post itself
      if (detection.category !== 'unknown') {
        indicators.push({
          id: makeId('rm'),
          type: 'url',
          value: `https://reddit.com${p.permalink}`,
          malwareFamily: detection.family,
          category: detection.category,
          severity: determineSeverity(text, detection.category),
          firstSeen: new Date(p.created_utc * 1000).toISOString(),
          lastSeen: nowISO(),
          source: 'Reddit',
          sourceUrl: `https://reddit.com${p.permalink}`,
          confidence: 50,
          tags: ['reddit', 'discussion'],
          description: p.title.substring(0, 200),
        });
      }
      
      // Also extract IOCs from post
      iocs.slice(0, 5).forEach(ioc => {
        indicators.push({
          id: makeId('rm'),
          type: ioc.type as any,
          value: ioc.value,
          malwareFamily: detection.family,
          category: detection.category,
          severity: determineSeverity(text, detection.category),
          firstSeen: new Date(p.created_utc * 1000).toISOString(),
          lastSeen: nowISO(),
          source: 'Reddit',
          sourceUrl: `https://reddit.com${p.permalink}`,
          confidence: 40,
          tags: ['reddit', 'extracted'],
          description: `Extracted from: ${p.title.substring(0, 100)}`,
        });
      });
    });
    
    console.log(`[Reddit Malware] ✅ Found ${indicators.length} indicators`);
    return indicators;
  } catch (err) {
    console.error('[Reddit Malware] ❌ Error:', err);
    return [];
  }
}

/* ============================================================================
   SOURCE 9: VX Underground (via archive searches)
============================================================================ */

async function searchVXUnderground(query: string): Promise<MalwareSample[]> {
  const samples: MalwareSample[] = [];
  
  try {
    console.log(`[VX Underground] Searching archive...`);
    
    // Search Archive.org for VX Underground mirrors
    const url = `https://archive.org/advancedsearch.php?q="${encodeURIComponent(query)}"+AND+(vxunderground+OR+malware+OR+sample)&fl[]=identifier&fl[]=title&fl[]=description&rows=15&output=json`;
    
    const res = await fetch(url);
    if (!res.ok) return [];
    
    const data = await res.json();
    const docs = data.response?.docs || [];
    
    docs.forEach((doc: any) => {
      const text = `${doc.title || ''} ${doc.description || ''}`;
      const detection = detectMalwareFamily(text);
      
      if (!isRelevantResult(text, query)) return;
      
      // Extract any hashes from description
      const hashes = extractIOCs(text).filter(i => i.type === 'sha256' || i.type === 'md5');
      
      samples.push({
        id: makeId('vx'),
        sha256: hashes.find(h => h.type === 'sha256')?.value || 'unknown',
        md5: hashes.find(h => h.type === 'md5')?.value,
        fileName: doc.title,
        fileType: 'archive',
        malwareFamily: detection.family,
        category: detection.category,
        severity: determineSeverity(text, detection.category),
        firstSeen: nowISO(),
        lastSeen: nowISO(),
        tags: ['vxunderground', 'archive'],
        c2Servers: [],
        mitreAttack: MITRE_TECHNIQUES[detection.category] || [],
        source: 'VX Underground (Archive)',
        sourceUrl: `https://archive.org/details/${doc.identifier}`,
      });
    });
    
    console.log(`[VX Underground] ✅ Found ${samples.length} samples`);
    return samples;
  } catch (err) {
    console.error('[VX Underground] ❌ Error:', err);
    return [];
  }
}

/* ============================================================================
   STEALER LOG DETECTION
============================================================================ */

async function searchStealerLogs(query: string): Promise<StealerLog[]> {
  const logs: StealerLog[] = [];
  
  try {
    console.log(`[StealerLogs] Searching for: "${query}"`);
    
    // Search paste sites for stealer log patterns
    const psbdmpUrl = `https://psbdmp.ws/api/v3/search/${encodeURIComponent(query)}`;
    
    let data: any;
    try {
      const res = await fetch(psbdmpUrl, { headers: { 'User-Agent': 'OSINT-Hub/2.0' } });
      if (res.ok) data = await res.json();
    } catch {
      const proxyRes = await fetch(`${CORS_PROXY}${encodeURIComponent(psbdmpUrl)}`);
      if (proxyRes.ok) data = await proxyRes.json();
    }
    
    if (!data) return [];
    
    const items = Array.isArray(data) ? data : (data.data || data.results || []);
    
    items.slice(0, 25).forEach((paste: any) => {
      const text = paste.text || paste.content || '';
      
      if (!isRelevantResult(text, query)) return;
      
      // Detect stealer patterns
      const stealerPatterns = [
        { regex: /redline/i, family: 'RedLine' },
        { regex: /raccoon/i, family: 'Raccoon' },
        { regex: /vidar/i, family: 'Vidar' },
        { regex: /lumma/i, family: 'Lumma' },
        { regex: /meta.?stealer/i, family: 'Meta' },
        { regex: /stealc/i, family: 'Stealc' },
        { regex: /aurora/i, family: 'Aurora' },
        { regex: /password[:\s]+\S+/gi, family: 'Generic' },
        { regex: /login[:\s]+\S+@\S+/gi, family: 'Generic' },
      ];
      
      let detectedFamily = 'Unknown';
      for (const pattern of stealerPatterns) {
        if (pattern.regex.test(text)) {
          detectedFamily = pattern.family;
          break;
        }
      }
      
      // Count credentials
      const emailMatches = text.match(/[\w.-]+@[\w.-]+\.\w+/g) || [];
      const passwordMatches = text.match(/password[:\s]+\S+/gi) || [];
      const cookieMatches = text.match(/cookie|session_id|csrf/gi) || [];
      const cardMatches = text.match(/\b\d{16}\b/g) || [];
      const walletMatches = text.match(/\b[13][a-km-zA-HJ-NP-Z1-9]{25,34}\b/g) || [];
      
      if (emailMatches.length > 0 || passwordMatches.length > 0) {
        logs.push({
          id: makeId('stlr'),
          stealerFamily: detectedFamily,
          timestamp: paste.time || paste.date || nowISO(),
          source: 'Psbdmp',
          sourceUrl: paste.id ? `https://pastebin.com/${paste.id}` : `https://psbdmp.ws/${paste.key}`,
          affectedDomain: query,
          credentialCount: emailMatches.length,
          cookieCount: cookieMatches.length,
          cardCount: cardMatches.length,
          walletCount: walletMatches.length,
          severity: passwordMatches.length > 10 ? 'critical' : 
                   passwordMatches.length > 5 ? 'high' : 'medium',
          preview: text.substring(0, 200).replace(/password[:\s]+\S+/gi, 'password:***'),
          tags: [detectedFamily.toLowerCase(), 'stealer-log'],
        });
      }
    });
    
    console.log(`[StealerLogs] ✅ Found ${logs.length} stealer logs`);
    return logs;
  } catch (err) {
    console.error('[StealerLogs] ❌ Error:', err);
    return [];
  }
}

/* ============================================================================
   MAIN SEARCH FUNCTION
============================================================================ */

export async function searchMalwareActivity(query: string): Promise<MalwareSearchResult> {
  const cacheKey = `malware-search:${query}`;
  const cached = await getCachedData(cacheKey);
  if (cached) {
    console.log(`[Malware Search] Using cached data`);
    return cached;
  }
  
  console.log(`\n========================================`);
  console.log(`[Malware Search] DEEP SCAN: "${query}"`);
  console.log(`========================================\n`);
  
  const startTime = Date.now();
  
  // Run all searches in parallel
  const results = await Promise.allSettled([
    searchThreatFox(query),
    searchURLhaus(query),
    searchMalwareBazaar(query),
    searchFeodoTracker(query),
    searchSSLBL(query),
    searchRansomwareLive(query),
    searchGitHubMalware(query),
    searchRedditMalware(query),
    searchVXUnderground(query),
    searchStealerLogs(query),
  ]);
  
  // Collect results
  const indicators: MalwareIndicator[] = [];
  const ransomwareGroups: RansomwareGroup[] = [];
  const stealerLogs: StealerLog[] = [];
  const c2Servers: C2Server[] = [];
  const malwareSamples: MalwareSample[] = [];
  
  const sourceNames = [
    'ThreatFox', 'URLhaus', 'MalwareBazaar', 'FeodoTracker', 
    'SSLBL', 'Ransomware.live', 'GitHub', 'Reddit', 'VXUnderground', 'StealerLogs'
  ];
  
  results.forEach((result, i) => {
    if (result.status === 'fulfilled') {
      console.log(`[${sourceNames[i]}] ✅ ${result.value.length} results`);
      
      if (i === 0 || i === 4 || i === 6 || i === 7) {
        indicators.push(...(result.value as MalwareIndicator[]));
      } else if (i === 1) {
        indicators.push(...(result.value as MalwareIndicator[]));
      } else if (i === 2 || i === 8) {
        malwareSamples.push(...(result.value as MalwareSample[]));
      } else if (i === 3) {
        c2Servers.push(...(result.value as C2Server[]));
      } else if (i === 5) {
        ransomwareGroups.push(...(result.value as RansomwareGroup[]));
      } else if (i === 9) {
        stealerLogs.push(...(result.value as StealerLog[]));
      }
    } else {
      console.warn(`[${sourceNames[i]}] ❌ Failed`);
    }
  });
  
  // Deduplicate
  const uniqueIndicators = Array.from(
    new Map(indicators.map(i => [i.value, i])).values()
  );
  
  const analysisTime = Date.now() - startTime;
  
  const searchResult: MalwareSearchResult = {
    indicators: uniqueIndicators.sort((a, b) => {
      const severityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
      return severityOrder[a.severity] - severityOrder[b.severity];
    }),
    ransomwareGroups,
    stealerLogs: stealerLogs.sort((a, b) => b.credentialCount - a.credentialCount),
    c2Servers: c2Servers.sort((a, b) => a.status === 'active' ? -1 : 1),
    malwareSamples,
    threatActors: [],
    stats: {
      totalIndicators: uniqueIndicators.length,
      criticalThreats: uniqueIndicators.filter(i => i.severity === 'critical').length,
      activeC2s: c2Servers.filter(c => c.status === 'active').length,
      ransomwareMatches: ransomwareGroups.length,
      stealerLogHits: stealerLogs.length,
    },
    analysisTime,
  };
  
  console.log(`\n[Malware Search] Completed in ${analysisTime}ms`);
  console.log(`[Malware Search] Total IOCs: ${searchResult.stats.totalIndicators}`);
  console.log(`[Malware Search] Critical: ${searchResult.stats.criticalThreats}\n`);
  
  if (searchResult.stats.totalIndicators > 0) {
    await cacheAPIResponse(cacheKey, searchResult, 30);
  }
  
  return searchResult;
}

/* ============================================================================
   EXPORTS
============================================================================ */

export {
  searchThreatFox,
  searchURLhaus,
  searchMalwareBazaar,
  searchFeodoTracker,
  searchRansomwareLive,
  searchStealerLogs,
  extractIOCs,
  detectMalwareFamily,
  KNOWN_RANSOMWARE_GROUPS,
  KNOWN_STEALERS,
  KNOWN_RATS,
  MITRE_TECHNIQUES,
};
