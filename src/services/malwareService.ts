// src/services/malwareService. ts
// Malware Intelligence Service - Samples, Families, Signatures, Hashes

import { cacheAPIResponse, getCachedData } from '@/lib/database';

/* ============================================================================
   TYPES
============================================================================ */

export interface MalwareSample {
  id: string;
  sha256: string;
  md5: string;
  sha1: string;
  fileType: string;
  fileSize: number;
  fileName: string;
  family: string;
  tags: string[];
  firstSeen: string;
  lastSeen: string;
  threatLevel: 'critical' | 'high' | 'medium' | 'low';
  signatures: string[];
  yara: string[];
  detectionRate: {
    detected: number;
    total: number;
    percentage: number;
  };
  source: string;
}

export interface MalwareFamily {
  name: string;
  aliases: string[];
  description: string;
  category: string;
  tactics: string[];
  techniques: string[];
  platforms: string[];
  firstSeen: string;
  samples: number;
  iocs: {
    hashes: string[];
    domains: string[];
    ips: string[];
  };
}

export interface MalwareSignature {
  id: string;
  name: string;
  type: 'yara' | 'snort' | 'suricata' | 'clamav';
  content: string;
  family: string;
  author: string;
  created: string;
  updated: string;
  tags: string[];
}

export interface HashLookupResult {
  hash: string;
  found: boolean;
  malicious: boolean;
  family?:  string;
  detections?: {
    engine: string;
    result: string;
    detected: boolean;
  }[];
  fileInfo?: {
    name: string;
    type: string;
    size: number;
  };
  behaviorTags?: string[];
  source:  string;
}

/* ============================================================================
   MALWAREBAZAAR API - LATEST MALWARE SAMPLES
============================================================================ */

export async function getLatestMalware(limit: number = 50): Promise<MalwareSample[]> {
  const cacheKey = `malware: latest:${limit}`;
  const cached = await getCachedData(cacheKey);
  if (cached) return cached;

  try {
    const response = await fetch('https://mb-api.abuse.ch/api/v1/', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: `query=get_recent&selector=${limit}`,
    });

    if (!response.ok) throw new Error('MalwareBazaar API failed');

    const data = await response.json();

    const samples: MalwareSample[] = data.data.map((item: any) => ({
      id: item.sha256_hash,
      sha256: item.sha256_hash,
      md5: item.md5_hash,
      sha1: item.sha1_hash,
      fileType: item.file_type,
      fileSize: parseInt(item.file_size),
      fileName: item.file_name,
      family: item.signature || 'Unknown',
      tags: item.tags || [],
      firstSeen:  item.first_seen,
      lastSeen: item.last_seen || item.first_seen,
      threatLevel: determineThreatLevel(item.tags, item.signature),
      signatures: item.yara_rules || [],
      yara: item.yara_rules || [],
      detectionRate: {
        detected: item.intelligence?. detections || 0,
        total: item.intelligence?.vendors || 0,
        percentage:  calculateDetectionRate(item.intelligence),
      },
      source: 'MalwareBazaar',
    }));

    await cacheAPIResponse(cacheKey, samples, 300);
    return samples;
  } catch (error) {
    console.error('MalwareBazaar error:', error);
    return [];
  }
}

/* ============================================================================
   HASH LOOKUP - MULTIPLE SOURCES
============================================================================ */

export async function lookupHash(hash: string): Promise<HashLookupResult[]> {
  const cacheKey = `malware:hash:${hash}`;
  const cached = await getCachedData(cacheKey);
  if (cached) return cached;

  const results: HashLookupResult[] = [];

  // MalwareBazaar
  try {
    const mbResponse = await fetch('https://mb-api.abuse.ch/api/v1/', {
      method: 'POST',
      headers: { 'Content-Type':  'application/x-www-form-urlencoded' },
      body: `query=get_info&hash=${hash}`,
    });

    if (mbResponse.ok) {
      const mbData = await mbResponse. json();
      
      if (mbData.query_status === 'ok' && mbData.data. length > 0) {
        const sample = mbData.data[0];
        results.push({
          hash,
          found: true,
          malicious: true,
          family: sample.signature,
          fileInfo: {
            name: sample.file_name,
            type: sample.file_type,
            size: parseInt(sample.file_size),
          },
          behaviorTags: sample.tags || [],
          detections: sample.vendor_intel?.vendors?. map((v:  any) => ({
            engine:  v.vendor,
            result: v.detection,
            detected: true,
          })) || [],
          source: 'MalwareBazaar',
        });
      }
    }
  } catch (error) {
    console.error('MalwareBazaar lookup error:', error);
  }

  // ThreatFox
  try {
    const tfResponse = await fetch('https://threatfox-api.abuse.ch/api/v1/', {
      method:  'POST',
      headers:  { 'Content-Type': 'application/json' },
      body: JSON. stringify({ query: 'search_hash', hash }),
    });

    if (tfResponse.ok) {
      const tfData = await tfResponse.json();
      
      if (tfData.query_status === 'ok' && tfData.data.length > 0) {
        const ioc = tfData.data[0];
        results.push({
          hash,
          found: true,
          malicious: true,
          family: ioc. malware,
          behaviorTags: [ioc.threat_type],
          source: 'ThreatFox',
        });
      }
    }
  } catch (error) {
    console.error('ThreatFox lookup error:', error);
  }

  await cacheAPIResponse(cacheKey, results, 3600);
  return results;
}

/* ============================================================================
   MALWARE FAMILIES
============================================================================ */

export async function getMalwareFamilies(): Promise<MalwareFamily[]> {
  const cacheKey = 'malware:families';
  const cached = await getCachedData(cacheKey);
  if (cached) return cached;

  try {
    const response = await fetch('https://mb-api.abuse.ch/api/v1/', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: 'query=get_taginfo&tag=exe',
    });

    if (!response.ok) throw new Error('Failed to fetch families');

    const data = await response.json();

    // Get unique families from recent samples
    const samples = await getLatestMalware(100);
    const familyMap = new Map<string, MalwareFamily>();

    samples.forEach(sample => {
      if (! familyMap.has(sample.family)) {
        familyMap. set(sample.family, {
          name: sample.family,
          aliases: [],
          description:  `Malware family: ${sample. family}`,
          category: categorizeFamily(sample.tags),
          tactics: extractTactics(sample.tags),
          techniques: [],
          platforms: [sample.fileType],
          firstSeen:  sample.firstSeen,
          samples: 1,
          iocs: {
            hashes:  [sample.sha256],
            domains: [],
            ips: [],
          },
        });
      } else {
        const family = familyMap.get(sample.family)!;
        family.samples++;
        family.iocs.hashes.push(sample.sha256);
      }
    });

    const families = Array.from(familyMap. values());
    await cacheAPIResponse(cacheKey, families, 3600);
    return families;
  } catch (error) {
    console.error('Get families error:', error);
    return [];
  }
}

/* ============================================================================
   YARA RULES / SIGNATURES
============================================================================ */

export async function getYaraRules(family?:  string): Promise<MalwareSignature[]> {
  const cacheKey = `malware:yara:${family || 'all'}`;
  const cached = await getCachedData(cacheKey);
  if (cached) return cached;

  const signatures: MalwareSignature[] = [];

  try {
    // Fetch from YaraRules GitHub repo
    const response = await fetch('https://api.github.com/repos/Yara-Rules/rules/contents/malware');
    
    if (!response. ok) throw new Error('Failed to fetch YARA rules');

    const files = await response.json();

    for (const file of files. slice(0, 20)) {
      if (file.name.endsWith('.yar') || file.name.endsWith('. yara')) {
        try {
          const contentResponse = await fetch(file.download_url);
          const content = await contentResponse.text();

          signatures.push({
            id: file.sha,
            name: file.name,
            type: 'yara',
            content,
            family: file.name.replace(/\.(yar|yara)$/, ''),
            author: 'Yara-Rules Community',
            created: '',
            updated: '',
            tags: ['yara', 'detection'],
          });
        } catch (e) {
          // Skip if individual file fails
        }
      }
    }

    await cacheAPIResponse(cacheKey, signatures, 86400);
    return signatures;
  } catch (error) {
    console.error('YARA rules error:', error);
    return [];
  }
}

/* ============================================================================
   SEARCH MALWARE
============================================================================ */

export async function searchMalware(query: string): Promise<MalwareSample[]> {
  const cacheKey = `malware:search:${query}`;
  const cached = await getCachedData(cacheKey);
  if (cached) return cached;

  try {
    const response = await fetch('https://mb-api.abuse.ch/api/v1/', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: `query=get_siginfo&signature=${encodeURIComponent(query)}`,
    });

    if (!response.ok) throw new Error('Search failed');

    const data = await response.json();

    const samples: MalwareSample[] = data.data?. map((item: any) => ({
      id: item.sha256_hash,
      sha256: item.sha256_hash,
      md5: item.md5_hash,
      sha1: item.sha1_hash,
      fileType: item.file_type,
      fileSize: parseInt(item.file_size),
      fileName: item.file_name,
      family: item.signature || query,
      tags: item.tags || [],
      firstSeen:  item.first_seen,
      lastSeen: item.last_seen || item.first_seen,
      threatLevel: determineThreatLevel(item.tags, item.signature),
      signatures: item.yara_rules || [],
      yara: item.yara_rules || [],
      detectionRate: {
        detected: item.intelligence?.detections || 0,
        total: item.intelligence?.vendors || 0,
        percentage: calculateDetectionRate(item.intelligence),
      },
      source: 'MalwareBazaar',
    })) || [];

    await cacheAPIResponse(cacheKey, samples, 600);
    return samples;
  } catch (error) {
    console.error('Search malware error:', error);
    return [];
  }
}

/* ============================================================================
   UTILITY FUNCTIONS
============================================================================ */

function determineThreatLevel(tags: string[], family:  string): 'critical' | 'high' | 'medium' | 'low' {
  const criticalKeywords = ['ransomware', 'trojan-banker', 'apt', 'rootkit'];
  const highKeywords = ['trojan', 'backdoor', 'stealer', 'rat'];
  const mediumKeywords = ['downloader', 'dropper', 'loader'];

  const allText = [... tags, family].join(' ').toLowerCase();

  if (criticalKeywords. some(k => allText.includes(k))) return 'critical';
  if (highKeywords.some(k => allText.includes(k))) return 'high';
  if (mediumKeywords.some(k => allText.includes(k))) return 'medium';
  return 'low';
}

function calculateDetectionRate(intelligence:  any): number {
  if (!intelligence || !intelligence.vendors) return 0;
  return Math.round((intelligence.detections / intelligence.vendors) * 100);
}

function categorizeFamily(tags: string[]): string {
  const tagStr = tags.join(' ').toLowerCase();
  
  if (tagStr.includes('ransomware')) return 'Ransomware';
  if (tagStr.includes('trojan')) return 'Trojan';
  if (tagStr.includes('backdoor')) return 'Backdoor';
  if (tagStr.includes('stealer')) return 'Infostealer';
  if (tagStr.includes('rat')) return 'RAT';
  if (tagStr.includes('miner')) return 'Cryptominer';
  if (tagStr.includes('adware')) return 'Adware';
  
  return 'Malware';
}

function extractTactics(tags: string[]): string[] {
  const tactics:  string[] = [];
  
  tags.forEach(tag => {
    if (tag.includes('persistence')) tactics.push('Persistence');
    if (tag.includes('execution')) tactics.push('Execution');
    if (tag.includes('exfiltration')) tactics.push('Exfiltration');
    if (tag.includes('lateral')) tactics.push('Lateral Movement');
    if (tag.includes('credential')) tactics.push('Credential Access');
  });
  
  return tactics;
}
